# """
# “ ==”的正式运算是相等，而“ is”的运算是标识。 一般使用“ ==”来比较两个对象的值。
# “ a == b”应解释为“ a的值是否等于b的值”。 在上述所有示例中，a 的值始终等于 b 的值(即使对于空列表示例也是如此)。 因此，“ a == b”始终为真。
# 运算符“ is ”是比较两个对象的标识是否相同。“a is b”的意思是“a的身份与b的身份相同”。
# """
# >>> a = 5
# >>> id(a)
# 1450375152
# >>> b = 5
# >>> id(b)
# 1450375152
# 首先是第一个和第二个示例中的结果不同。 显示不同结果的原因是Python存储了一个介于-5到256之间的整数的数组列表，每个整数具有固定的标识。
# 当我们在此范围内分配整数变量时，Python会将此变量的标识分配为数组列表内整数的整数。
# 结果，对于第一个示例，由于a和b的标识都是从数组列表中获得的，因此它们的标识当然是相同的，因此 “a is b” 为True。
#
# >>> a = 1000
# >>> id(a)
# 12728608
# >>> b = 1000
# >>> id(b)
# 13620208
# 首先是第一个和第二个示例中的结果不同。 显示不同结果的原因是Python存储了一个介于-5到256之间的整数的数组列表，每个整数具有固定的标识。
# 当我们在此范围内分配整数变量时，Python会将此变量的标识分配为数组列表内整数的整数。
# 结果，对于第一个示例，由于a和b的标识都是从数组列表中获得的，因此它们的标识当然是相同的，因此 “a is b” 为True。
#
# >>> a = [1,10,100,1000]
# >>> b = [1,10,100,1000]
# >>> a == b
# True
# >>> a is b
# False
# >>> id(a)
# 12578024
# >>> id(b)
# 12578056
# 由于 Python 不存储“空列表”对象，因此 Python 创建了一个新对象并分配了“空列表”值。无论两个列表为空还是元素相同，结果都是相同的。
#
# >>> a = 1000
# >>> b = 2000
# >>> id(a)
# 2047616
# >>> id(b)
# 5034992
# >>> a = b
# >>> id(a)
# 5034992
# >>> id(b)
# 5034992
# >>> a
# 2000
# >>> b
# 2000
# 如上所示，在 a = b 之后，a 的身份更改为 b 的身份。a = b 将 b 的身份分配给 a 。因此 a 和 b 具有相同的标识，
# 因此 a 的值现在与 b 的值相同(即2000)。
#
#
# >>> a = [1,2,3]
# >>> id(a)
# 5237992
# >>> b = a
# >>> id(b)
# 5237992
# >>> a.append(4)
# >>> a
# [1, 2, 3, 4]
# >>> b
# [1, 2, 3, 4]
#
# >>> import copy
# >>> a = [1,2,3]
# >>> b= copy.deepcopy(a)
# >>> id(a)
# 39785256
# >>> id(b)
# 5237992
#
# >>> a = [1,2,3]
# >>> id(a)
# 39785256
# >>> b = a[:]
# >>> id(b)
# 23850216
# >>> a.append(4)
# >>> a
# [1, 2, 3, 4]
# >>> b
# [1, 2, 3]
# 在上面的示例中，由于 a 和 b 具有相同的标识，因此它们的值必须相同。
# 所以，在将新元素添加到 a 之后，b 的值也会受到影响。为避免这种情况，如果要将值从一个对象复制到另一个对象而不引用相同的标识，
# 则所有方法之一是在 copy 模块中使用 deepcopy 。 对于列表，我们还可以通过 b = a [:] 执行。